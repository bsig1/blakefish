//
// Created by mrsig on 7/1/2025.
//
#include "magic.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "movegen.h"

const U64 rook_magics[64] = {
	0x3080038420400010, 0x1040400010002000, 0x4880200210000980, 0x5280080010000482,
	0x0200040200081020, 0x2100080100020400, 0x4280008001000200, 0x01000a4425820300,
	0x0029002100800040, 0x4503400040201004, 0x0209002001004018, 0x1131000a10002100,
	0x0009000800120500, 0x010e001804820010, 0x0029000402000100, 0x2002000d01c40292,
	0x0080084000200c40, 0x0010004040002002, 0x0201030020004014, 0x080012000a420020,
	0x0129010008001204, 0x6109010008040002, 0x0950010100020004, 0x00803a0000c50284,
	0x0080004100210080, 0x0000200240100140, 0x0020004040100800, 0x4018090300201000,
	0x4802010a00102004, 0x2001000900040002, 0x04a02104001002a8, 0x2188108200204401,
	0x0040400020800080, 0x0880402000401004, 0x0010040800202000, 0x0604410a02001020,
	0x200200206a001410, 0x0086000400810080, 0x428200040600080b, 0x2001000041000082,
	0x0080002000484000, 0x0210002002c24000, 0x401a200100410014, 0x0005021000a30009,
	0x0218000509010010, 0x4000400410080120, 0x0000020801040010, 0x0029040040820011,
	0x4080400024800280, 0x0500200040100440, 0x2880142001004100, 0x412020400a001200,
	0x018c028004080080, 0x0884001020080401, 0x0000210810420400, 0x0801048745040200,
	0x4401002040120082, 0x0000408200210012, 0x0000110008200441, 0x2010002004100901,
	0x0801000800040211, 0x480d000400820801, 0x0820104201280084, 0x1001040311802142
};

const U64 bishop_magics[64] = {
	0x0004501001002080, 0x0854080841002c00, 0x0804410405000000, 0x08111042002d00a0,
	0x0104042000000508, 0x0142020220030810, 0x0100480424222004, 0x440520880c012000,
	0x0000442810640480, 0x0010100210911200, 0x0010448404084002, 0x0200040400884480,
	0x4901184841101400, 0x0209708220220420, 0x0082040201442118, 0x0400008400883480,
	0x0005245838080840, 0x0004401010820043, 0x400616e410220200, 0x0020400401002000,
	0x0401000820080000, 0x0000402200500418, 0x2203000201292000, 0x2842024900420231,
	0x0008040040044800, 0x0902621008480825, 0x1404010810090024, 0x004004004a010810,
	0x4041001013004000, 0x1400490002010101, 0x0808090002010120, 0x00110042020220a0,
	0x00043040001414c0, 0x0108110400300401, 0x080200b000220384, 0x2010280800220a00,
	0x0001080200002200, 0x004c082200022280, 0x0110010050a90400, 0x1072008820210408,
	0x0309080904404000, 0x4004024a10040280, 0x0000201402011020, 0x0060082011001800,
	0x49a8120204120200, 0x0060089020810041, 0x0210024801201040, 0x0022008106014108,
	0x0002026120080048, 0x600101012120008c, 0x0240042108080102, 0x000000a120884002,
	0x100100c010410202, 0x2000218202220020, 0x0008200842004808, 0x0251020200420229,
	0x000224004410288a, 0x4000204100882040, 0x0010300022015001, 0x2020048002420208,
	0x0c00004021204100, 0x0044005022280840, 0x0008280214184208, 0x20c0210214004180
};

const int rook_shifts[64] = {
	52,53,53,53,53,53,53,52,
	53,54,54,54,54,54,54,53,
	53,54,54,54,54,54,54,53,
	53,54,54,54,54,54,54,53,
	53,54,54,54,54,54,54,53,
	53,54,54,54,54,54,54,53,
	53,54,54,54,54,54,54,53,
	52,53,53,53,53,53,53,52
};

const int bishop_shifts[64] = {
	58,59,59,59,59,59,59,58,
	59,59,59,59,59,59,59,59,
	59,59,57,57,57,57,59,59,
	59,59,57,55,55,57,59,59,
	59,59,57,55,55,57,59,59,
	59,59,57,57,57,57,59,59,
	59,59,59,59,59,59,59,59,
	58,59,59,59,59,59,59,58
};

const U64 rook_masks[64] = {
	0x000101010101017e, 0x000202020202027c, 0x000404040404047a, 0x0008080808080876,
	0x001010101010106e, 0x002020202020205e, 0x004040404040403e, 0x008080808080807e,
	0x0001010101017e00, 0x0002020202027c00, 0x0004040404047a00, 0x0008080808087600,
	0x0010101010106e00, 0x0020202020205e00, 0x0040404040403e00, 0x0080808080807e00,
	0x00010101017e0100, 0x00020202027c0200, 0x00040404047a0400, 0x0008080808760800,
	0x00101010106e1000, 0x00202020205e2000, 0x00404040403e4000, 0x00808080807e8000,
	0x000101017e010100, 0x000202027c020200, 0x000404047a040400, 0x0008080876080800,
	0x001010106e101000, 0x002020205e202000, 0x004040403e404000, 0x008080807e808000,
	0x0001017e01010100, 0x0002027c02020200, 0x0004047a04040400, 0x0008087608080800,
	0x0010106e10101000, 0x0020205e20202000, 0x0040403e40404000, 0x0080807e80808000,
	0x00017e0101010100, 0x00027c0202020200, 0x00047a0404040400, 0x0008760808080800,
	0x00106e1010101000, 0x00205e2020202000, 0x00403e4040404000, 0x00807e8080808000,
	0x007e010101010100, 0x007c020202020200, 0x007a040404040400, 0x0076080808080800,
	0x006e101010101000, 0x005e202020202000, 0x003e404040404000, 0x007e808080808000,
	0x7e01010101010100, 0x7c02020202020200, 0x7a04040404040400, 0x7608080808080800,
	0x6e10101010101000, 0x5e20202020202000, 0x3e40404040404000, 0x7e80808080808000
};

const U64 bishop_masks[64] = {
	0x0040201008040200, 0x0000402010080400, 0x0000004020100a00, 0x0000000040221400,
	0x0000000002442800, 0x0000000204085000, 0x0000020408102000, 0x0002040810204000,
	0x0020100804020000, 0x0040201008040000, 0x00004020100a0000, 0x0000004022140000,
	0x0000000244280000, 0x0000020408500000, 0x0002040810200000, 0x0004081020400000,
	0x0010080402000200, 0x0020100804000400, 0x004020100a000a00, 0x0000402214001400,
	0x0000024428002800, 0x0002040850005000, 0x0004081020002000, 0x0008102040004000,
	0x0008040200020400, 0x0010080400040800, 0x0020100a000a1000, 0x0040221400142200,
	0x0002442800284400, 0x0004085000500800, 0x0008102000201000, 0x0010204000402000,
	0x0004020002040800, 0x0008040004081000, 0x00100a000a102000, 0x0022140014224000,
	0x0044280028440200, 0x0008500050080400, 0x0010200020100800, 0x0020400040201000,
	0x0002000204081000, 0x0004000408102000, 0x000a000a10204000, 0x0014001422400000,
	0x0028002844020000, 0x0050005008040200, 0x0020002010080400, 0x0040004020100800,
	0x0000020408102000, 0x0000040810204000, 0x00000a1020400000, 0x0000142240000000,
	0x0000284402000000, 0x0000500804020000, 0x0000201008040200, 0x0000402010080400,
	0x0002040810204000, 0x0004081020400000, 0x000a102040000000, 0x0014224000000000,
	0x0028440200000000, 0x0050080402000000, 0x0020100804020000, 0x0040201008040200
};

U64 set_blockers(const int index, const U64 mask) {
	U64 blockers = 0ULL;
	int bit_index = 0;

	for (int square = 0; square < 64; square++) {
		if (mask & (1ULL << square)) {
			if (index & (1 << bit_index)) {
				blockers |= (1ULL << square);
			}
			bit_index++;
		}
	}

	return blockers;
}

U64 random_magic_candidate() {
	return ((U64) rand() & 0xFFFF) |
		   ((U64) rand() & 0xFFFF) << 16 |
		   ((U64) rand() & 0xFFFF) << 32 |
		   ((U64) rand() & 0xFFFF) << 48;
}

U64 find_magic_number(const int square, U64 (*attack_on_the_fly)(U64, U64), const U64 mask) {
	int relevant_bits = popcount(mask);
	int num_blockers = 1 << relevant_bits;
	U64 *blocker_boards = malloc(sizeof(U64) * num_blockers);
	U64 *attack_boards = malloc(sizeof(U64) * num_blockers);

	for (int i = 0; i < num_blockers; i++) {
		blocker_boards[i] = set_blockers(i, mask);
		attack_boards[i] = attack_on_the_fly(1ULL << square, blocker_boards[i]);
	}

	int max_attempts = 100000000;
	for (int attempt = 0; attempt < max_attempts; attempt++) {
		U64 magic = random_magic_candidate() & random_magic_candidate() & random_magic_candidate();

		if (popcount((magic * mask) & 0xFF00000000000000ULL) < 6)
			continue;

		U64 *used_attacks = calloc(num_blockers, sizeof(U64));
		int fail = 0;

		for (int i = 0; i < num_blockers; i++) {
			U64 index = (blocker_boards[i] * magic) >> (64 - relevant_bits);
			if (used_attacks[index] && used_attacks[index] != attack_boards[i]) {
				fail = 1;
				break;
			}
			used_attacks[index] = attack_boards[i];
		}

		free(used_attacks);

		if (!fail) {
			free(blocker_boards);
			free(attack_boards);
			return magic;
		}
	}

	free(blocker_boards);
	free(attack_boards);
	return 0; // failed
}

U64 **build_magic_attack_table(
	const U64 magic_numbers[64],
	const int shifts[64],
	U64 (*generate_mask)(int),
	U64 (*attack_on_the_fly)(U64, U64),
	int table_sizes[64]
) {
	U64 **table = calloc(64, sizeof *table);
	if (!table) { perror("calloc"); exit(1); }

	for (int sq = 0; sq < 64; sq++) {
		// 1) compute mask and its bit-count
		U64 mask = generate_mask(sq);
		int mask_bits = __builtin_popcountll(mask);

		// 2) use the precomputed shift
		int shift = shifts[sq];

		// (optional sanity check)
		if (mask_bits + shift != 64) {
			printf("hi");
		}
		// 3) size & alloc table
		int table_size = 1 << mask_bits;
		table_sizes[sq] = table_size;
		U64 *attacks = calloc(table_size, sizeof *attacks);
		if (!attacks) { perror("calloc"); exit(1); }

		// 4) fill entries
		for (int i = 0; i < table_size; i++) {
			U64 blockers = set_blockers(i, mask);
			size_t idx = (size_t)((blockers * magic_numbers[sq]) >> shift);
			assert(idx < (size_t)table_size);

			U64 atk = attack_on_the_fly(1ULL << sq, blockers);
			if (attacks[idx] && attacks[idx] != atk) {
				fprintf(stderr,
					"Collision at sq=%d idx=%zu bits=%d\n"
					"  blockers=0x%016llx magic=0x%016llx shift=%d\n"
					"  old=0x%016llx new=0x%016llx\n",
					sq, idx, mask_bits,
					blockers, magic_numbers[sq], shift,
					attacks[idx], atk
				);
				exit(1);
			}
			attacks[idx] = atk;
		}

		table[sq] = attacks;
	}

	return table;
}